// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 %s -cl-std=CL2.0 -emit-llvm -O0 -o - -triple=amdgcn-amd-amdhsa \
// RUN:   | FileCheck %s

// Also test serialization of atomic operations here, to avoid duplicating the test.
// RUN: %clang_cc1 %s -cl-std=CL2.0 -emit-pch -O0 -o %t -triple=amdgcn-amd-amdhsa
// RUN: %clang_cc1 %s -cl-std=CL2.0 -include-pch %t -O0 -triple=amdgcn-amd-amdhsa \
// RUN:   -emit-llvm -o - | FileCheck %s

#ifndef ALREADY_INCLUDED
#define ALREADY_INCLUDED

#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable
#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable

typedef __INTPTR_TYPE__ intptr_t;
typedef int int8 __attribute__((ext_vector_type(8)));

typedef enum memory_order {
  memory_order_relaxed = __ATOMIC_RELAXED,
  memory_order_acquire = __ATOMIC_ACQUIRE,
  memory_order_release = __ATOMIC_RELEASE,
  memory_order_acq_rel = __ATOMIC_ACQ_REL,
  memory_order_seq_cst = __ATOMIC_SEQ_CST
} memory_order;

typedef enum memory_scope {
  memory_scope_work_item = __OPENCL_MEMORY_SCOPE_WORK_ITEM,
  memory_scope_work_group = __OPENCL_MEMORY_SCOPE_WORK_GROUP,
  memory_scope_device = __OPENCL_MEMORY_SCOPE_DEVICE,
  memory_scope_all_svm_devices = __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES,
#if defined(cl_intel_subgroups) || defined(cl_khr_subgroups)
  memory_scope_sub_group = __OPENCL_MEMORY_SCOPE_SUB_GROUP
#endif
} memory_scope;

atomic_int j;

// CHECK-LABEL: define dso_local void @fi1(
// CHECK-SAME: ptr noundef [[I:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[X:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP1:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP2:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP3:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    store ptr [[I]], ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP1]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    store i32 [[TMP2]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load atomic i32, ptr [[TMP3]] syncscope("agent") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP4]], ptr addrspace(5) [[ATOMIC_TEMP1]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP1]], align 4
// CHECK-NEXT:    store i32 [[TMP5]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = load atomic i32, ptr [[TMP6]] seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP7]], ptr addrspace(5) [[ATOMIC_TEMP2]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP2]], align 4
// CHECK-NEXT:    store i32 [[TMP8]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    [[TMP9:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP10:%.*]] = load atomic i32, ptr [[TMP9]] syncscope("wavefront") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP10]], ptr addrspace(5) [[ATOMIC_TEMP3]], align 4
// CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP3]], align 4
// CHECK-NEXT:    store i32 [[TMP11]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    ret void
//
void fi1(atomic_int *i) {
  int x = __opencl_atomic_load(i, memory_order_seq_cst, memory_scope_work_group);

  x = __opencl_atomic_load(i, memory_order_seq_cst, memory_scope_device);

  x = __opencl_atomic_load(i, memory_order_seq_cst, memory_scope_all_svm_devices);

  x = __opencl_atomic_load(i, memory_order_seq_cst, memory_scope_sub_group);
}

// CHECK-LABEL: define dso_local void @fi2(
// CHECK-SAME: ptr noundef [[I:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    store ptr [[I]], ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    store i32 1, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    store atomic i32 [[TMP1]], ptr [[TMP0]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    ret void
//
void fi2(atomic_int *i) {
  __opencl_atomic_store(i, 1, memory_order_seq_cst, memory_scope_work_group);
}

// CHECK-LABEL: define dso_local void @test_addr(
// CHECK-SAME: ptr addrspace(1) noundef [[IG:%.*]], ptr addrspace(5) noundef [[IP:%.*]], ptr addrspace(3) noundef [[IL:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[IG_ADDR:%.*]] = alloca ptr addrspace(1), align 8, addrspace(5)
// CHECK-NEXT:    [[IP_ADDR:%.*]] = alloca ptr addrspace(5), align 4, addrspace(5)
// CHECK-NEXT:    [[IL_ADDR:%.*]] = alloca ptr addrspace(3), align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP1:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP2:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    store ptr addrspace(1) [[IG]], ptr addrspace(5) [[IG_ADDR]], align 8
// CHECK-NEXT:    store ptr addrspace(5) [[IP]], ptr addrspace(5) [[IP_ADDR]], align 4
// CHECK-NEXT:    store ptr addrspace(3) [[IL]], ptr addrspace(5) [[IL_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(1), ptr addrspace(5) [[IG_ADDR]], align 8
// CHECK-NEXT:    store i32 1, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    store atomic i32 [[TMP1]], ptr addrspace(1) [[TMP0]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr addrspace(5), ptr addrspace(5) [[IP_ADDR]], align 4
// CHECK-NEXT:    store i32 1, ptr addrspace(5) [[DOTATOMICTMP1]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP1]], align 4
// CHECK-NEXT:    store atomic i32 [[TMP3]], ptr addrspace(5) [[TMP2]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr addrspace(3), ptr addrspace(5) [[IL_ADDR]], align 4
// CHECK-NEXT:    store i32 1, ptr addrspace(5) [[DOTATOMICTMP2]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP2]], align 4
// CHECK-NEXT:    store atomic i32 [[TMP5]], ptr addrspace(3) [[TMP4]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    ret void
//
void test_addr(global atomic_int *ig, private atomic_int *ip, local atomic_int *il) {
  __opencl_atomic_store(ig, 1, memory_order_seq_cst, memory_scope_work_group);

  __opencl_atomic_store(ip, 1, memory_order_seq_cst, memory_scope_work_group);

  __opencl_atomic_store(il, 1, memory_order_seq_cst, memory_scope_work_group);
}

// CHECK-LABEL: define dso_local void @fi3(
// CHECK-SAME: ptr noundef [[I:%.*]], ptr noundef [[UI:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[UI_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[X:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP1:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP2:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP3:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP4:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP5:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP6:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP7:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP8:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    store ptr [[I]], ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    store ptr [[UI]], ptr addrspace(5) [[UI_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    store i32 1, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = atomicrmw and ptr [[TMP0]], i32 [[TMP1]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP2]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    store i32 [[TMP3]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    store i32 1, ptr addrspace(5) [[DOTATOMICTMP1]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP1]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = atomicrmw min ptr [[TMP4]], i32 [[TMP5]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP6]], ptr addrspace(5) [[ATOMIC_TEMP2]], align 4
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP2]], align 4
// CHECK-NEXT:    store i32 [[TMP7]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    store i32 1, ptr addrspace(5) [[DOTATOMICTMP3]], align 4
// CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP3]], align 4
// CHECK-NEXT:    [[TMP10:%.*]] = atomicrmw max ptr [[TMP8]], i32 [[TMP9]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP10]], ptr addrspace(5) [[ATOMIC_TEMP4]], align 4
// CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP4]], align 4
// CHECK-NEXT:    store i32 [[TMP11]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    [[TMP12:%.*]] = load ptr, ptr addrspace(5) [[UI_ADDR]], align 8
// CHECK-NEXT:    store i32 1, ptr addrspace(5) [[DOTATOMICTMP5]], align 4
// CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP5]], align 4
// CHECK-NEXT:    [[TMP14:%.*]] = atomicrmw umin ptr [[TMP12]], i32 [[TMP13]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP14]], ptr addrspace(5) [[ATOMIC_TEMP6]], align 4
// CHECK-NEXT:    [[TMP15:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP6]], align 4
// CHECK-NEXT:    store i32 [[TMP15]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    [[TMP16:%.*]] = load ptr, ptr addrspace(5) [[UI_ADDR]], align 8
// CHECK-NEXT:    store i32 1, ptr addrspace(5) [[DOTATOMICTMP7]], align 4
// CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP7]], align 4
// CHECK-NEXT:    [[TMP18:%.*]] = atomicrmw umax ptr [[TMP16]], i32 [[TMP17]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP18]], ptr addrspace(5) [[ATOMIC_TEMP8]], align 4
// CHECK-NEXT:    [[TMP19:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP8]], align 4
// CHECK-NEXT:    store i32 [[TMP19]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    ret void
//
void fi3(atomic_int *i, atomic_uint *ui) {
  int x = __opencl_atomic_fetch_and(i, 1, memory_order_seq_cst, memory_scope_work_group);

  x = __opencl_atomic_fetch_min(i, 1, memory_order_seq_cst, memory_scope_work_group);

  x = __opencl_atomic_fetch_max(i, 1, memory_order_seq_cst, memory_scope_work_group);

  x = __opencl_atomic_fetch_min(ui, 1, memory_order_seq_cst, memory_scope_work_group);

  x = __opencl_atomic_fetch_max(ui, 1, memory_order_seq_cst, memory_scope_work_group);
}

// CHECK-LABEL: define dso_local zeroext i1 @fi4(
// CHECK-SAME: ptr noundef [[I:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[CMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[CMPXCHG_BOOL:%.*]] = alloca i8, align 1, addrspace(5)
// CHECK-NEXT:    store ptr [[I]], ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    store i32 0, ptr addrspace(5) [[CMP]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    store i32 1, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[CMPXCHG_EXPECTED:%.*]] = load i32, ptr addrspace(5) [[CMP]], align 4
// CHECK-NEXT:    [[CMPXCHG_DESIRED:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[CMPXCHG_PAIR:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED]], i32 [[CMPXCHG_DESIRED]] syncscope("workgroup-one-as") acquire acquire, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV]], ptr addrspace(5) [[CMP]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR]], 1
// CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr addrspace(5) [[CMPXCHG_BOOL]], align 1
// CHECK-NEXT:    [[LOADEDV:%.*]] = trunc i8 [[TMP1]] to i1
// CHECK-NEXT:    ret i1 [[LOADEDV]]
//
bool fi4(atomic_int *i) {
  int cmp = 0;
  return __opencl_atomic_compare_exchange_strong(i, &cmp, 1, memory_order_acquire, memory_order_acquire, memory_scope_work_group);
}

// CHECK-LABEL: define dso_local void @fi5(
// CHECK-SAME: ptr noundef [[I:%.*]], i32 noundef [[SCOPE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[SCOPE_ADDR:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[X:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    store ptr [[I]], ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    store i32 [[SCOPE]], ptr addrspace(5) [[SCOPE_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(5) [[SCOPE_ADDR]], align 4
// CHECK-NEXT:    switch i32 [[TMP1]], label %[[OPENCL_ALLSVMDEVICES:.*]] [
// CHECK-NEXT:      i32 1, label %[[OPENCL_WORKGROUP:.*]]
// CHECK-NEXT:      i32 2, label %[[OPENCL_DEVICE:.*]]
// CHECK-NEXT:      i32 4, label %[[OPENCL_SUBGROUP:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[OPENCL_WORKGROUP]]:
// CHECK-NEXT:    [[TMP2:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP2]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE:.*]]
// CHECK:       [[OPENCL_DEVICE]]:
// CHECK-NEXT:    [[TMP3:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("agent") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP3]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// CHECK:       [[OPENCL_ALLSVMDEVICES]]:
// CHECK-NEXT:    [[TMP4:%.*]] = load atomic i32, ptr [[TMP0]] seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP4]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// CHECK:       [[OPENCL_SUBGROUP]]:
// CHECK-NEXT:    [[TMP5:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("wavefront") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP5]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// CHECK:       [[ATOMIC_SCOPE_CONTINUE]]:
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    store i32 [[TMP6]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    ret void
//
void fi5(atomic_int *i, int scope) {
  int x = __opencl_atomic_load(i, memory_order_seq_cst, scope);
}

// CHECK-LABEL: define dso_local void @fi6(
// CHECK-SAME: ptr noundef [[I:%.*]], i32 noundef [[ORDER:%.*]], i32 noundef [[SCOPE:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[ORDER_ADDR:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[SCOPE_ADDR:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[X:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    store ptr [[I]], ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    store i32 [[ORDER]], ptr addrspace(5) [[ORDER_ADDR]], align 4
// CHECK-NEXT:    store i32 [[SCOPE]], ptr addrspace(5) [[SCOPE_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(5) [[ORDER_ADDR]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(5) [[SCOPE_ADDR]], align 4
// CHECK-NEXT:    switch i32 [[TMP1]], label %[[MONOTONIC:.*]] [
// CHECK-NEXT:      i32 1, label %[[ACQUIRE:.*]]
// CHECK-NEXT:      i32 2, label %[[ACQUIRE]]
// CHECK-NEXT:      i32 5, label %[[SEQCST:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[MONOTONIC]]:
// CHECK-NEXT:    switch i32 [[TMP2]], label %[[OPENCL_ALLSVMDEVICES:.*]] [
// CHECK-NEXT:      i32 1, label %[[OPENCL_WORKGROUP:.*]]
// CHECK-NEXT:      i32 2, label %[[OPENCL_DEVICE:.*]]
// CHECK-NEXT:      i32 4, label %[[OPENCL_SUBGROUP:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[ACQUIRE]]:
// CHECK-NEXT:    switch i32 [[TMP2]], label %[[OPENCL_ALLSVMDEVICES3:.*]] [
// CHECK-NEXT:      i32 1, label %[[OPENCL_WORKGROUP1:.*]]
// CHECK-NEXT:      i32 2, label %[[OPENCL_DEVICE2:.*]]
// CHECK-NEXT:      i32 4, label %[[OPENCL_SUBGROUP4:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[SEQCST]]:
// CHECK-NEXT:    switch i32 [[TMP2]], label %[[OPENCL_ALLSVMDEVICES8:.*]] [
// CHECK-NEXT:      i32 1, label %[[OPENCL_WORKGROUP6:.*]]
// CHECK-NEXT:      i32 2, label %[[OPENCL_DEVICE7:.*]]
// CHECK-NEXT:      i32 4, label %[[OPENCL_SUBGROUP9:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[ATOMIC_CONTINUE:.*]]:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    store i32 [[TMP3]], ptr addrspace(5) [[X]], align 4
// CHECK-NEXT:    ret void
// CHECK:       [[OPENCL_WORKGROUP]]:
// CHECK-NEXT:    [[TMP4:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("workgroup-one-as") monotonic, align 4
// CHECK-NEXT:    store i32 [[TMP4]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE:.*]]
// CHECK:       [[OPENCL_DEVICE]]:
// CHECK-NEXT:    [[TMP5:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("agent-one-as") monotonic, align 4
// CHECK-NEXT:    store i32 [[TMP5]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// CHECK:       [[OPENCL_ALLSVMDEVICES]]:
// CHECK-NEXT:    [[TMP6:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("one-as") monotonic, align 4
// CHECK-NEXT:    store i32 [[TMP6]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// CHECK:       [[OPENCL_SUBGROUP]]:
// CHECK-NEXT:    [[TMP7:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("wavefront-one-as") monotonic, align 4
// CHECK-NEXT:    store i32 [[TMP7]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE]]
// CHECK:       [[ATOMIC_SCOPE_CONTINUE]]:
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE]]
// CHECK:       [[OPENCL_WORKGROUP1]]:
// CHECK-NEXT:    [[TMP8:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("workgroup-one-as") acquire, align 4
// CHECK-NEXT:    store i32 [[TMP8]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE5:.*]]
// CHECK:       [[OPENCL_DEVICE2]]:
// CHECK-NEXT:    [[TMP9:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("agent-one-as") acquire, align 4
// CHECK-NEXT:    store i32 [[TMP9]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE5]]
// CHECK:       [[OPENCL_ALLSVMDEVICES3]]:
// CHECK-NEXT:    [[TMP10:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("one-as") acquire, align 4
// CHECK-NEXT:    store i32 [[TMP10]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE5]]
// CHECK:       [[OPENCL_SUBGROUP4]]:
// CHECK-NEXT:    [[TMP11:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("wavefront-one-as") acquire, align 4
// CHECK-NEXT:    store i32 [[TMP11]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE5]]
// CHECK:       [[ATOMIC_SCOPE_CONTINUE5]]:
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE]]
// CHECK:       [[OPENCL_WORKGROUP6]]:
// CHECK-NEXT:    [[TMP12:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP12]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE10:.*]]
// CHECK:       [[OPENCL_DEVICE7]]:
// CHECK-NEXT:    [[TMP13:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("agent") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP13]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE10]]
// CHECK:       [[OPENCL_ALLSVMDEVICES8]]:
// CHECK-NEXT:    [[TMP14:%.*]] = load atomic i32, ptr [[TMP0]] seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP14]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE10]]
// CHECK:       [[OPENCL_SUBGROUP9]]:
// CHECK-NEXT:    [[TMP15:%.*]] = load atomic i32, ptr [[TMP0]] syncscope("wavefront") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP15]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    br label %[[ATOMIC_SCOPE_CONTINUE10]]
// CHECK:       [[ATOMIC_SCOPE_CONTINUE10]]:
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE]]
//
void fi6(atomic_int *i, int order, int scope) {
  int x = __opencl_atomic_load(i, order, scope);
}

// CHECK-LABEL: define dso_local float @ff1(
// CHECK-SAME: ptr addrspace(1) noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[D_ADDR:%.*]] = alloca ptr addrspace(1), align 8, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca float, align 4, addrspace(5)
// CHECK-NEXT:    store ptr addrspace(1) [[D]], ptr addrspace(5) [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(1), ptr addrspace(5) [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load atomic i32, ptr addrspace(1) [[TMP0]] syncscope("workgroup-one-as") monotonic, align 4
// CHECK-NEXT:    store i32 [[TMP1]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load float, ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    ret float [[TMP2]]
//
float ff1(global atomic_float *d) {
  return __opencl_atomic_load(d, memory_order_relaxed, memory_scope_work_group);
}

// CHECK-LABEL: define dso_local void @ff2(
// CHECK-SAME: ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca float, align 4, addrspace(5)
// CHECK-NEXT:    store ptr [[D]], ptr addrspace(5) [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[D_ADDR]], align 8
// CHECK-NEXT:    store float 1.000000e+00, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    store atomic i32 [[TMP1]], ptr [[TMP0]] syncscope("workgroup-one-as") release, align 4
// CHECK-NEXT:    ret void
//
void ff2(atomic_float *d) {
  __opencl_atomic_store(d, 1, memory_order_release, memory_scope_work_group);
}

// CHECK-LABEL: define dso_local float @ff3(
// CHECK-SAME: ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca float, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca float, align 4, addrspace(5)
// CHECK-NEXT:    store ptr [[D]], ptr addrspace(5) [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[D_ADDR]], align 8
// CHECK-NEXT:    store float 2.000000e+00, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = atomicrmw xchg ptr [[TMP0]], i32 [[TMP1]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP2]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load float, ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    ret float [[TMP3]]
//
float ff3(atomic_float *d) {
  return __opencl_atomic_exchange(d, 2, memory_order_seq_cst, memory_scope_work_group);
}

// CHECK-LABEL: define dso_local float @ff4(
// CHECK-SAME: ptr addrspace(1) noundef [[D:%.*]], float noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[D_ADDR:%.*]] = alloca ptr addrspace(1), align 8, addrspace(5)
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca float, align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca float, align 4, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca float, align 4, addrspace(5)
// CHECK-NEXT:    store ptr addrspace(1) [[D]], ptr addrspace(5) [[D_ADDR]], align 8
// CHECK-NEXT:    store float [[A]], ptr addrspace(5) [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(1), ptr addrspace(5) [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr addrspace(5) [[A_ADDR]], align 4
// CHECK-NEXT:    store float [[TMP1]], ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load float, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = atomicrmw fadd ptr addrspace(1) [[TMP0]], float [[TMP2]] syncscope("workgroup-one-as") monotonic, align 4
// CHECK-NEXT:    store float [[TMP3]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = load float, ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    ret float [[TMP4]]
//
float ff4(global atomic_float *d, float a) {
  return __opencl_atomic_fetch_add(d, a, memory_order_relaxed, memory_scope_work_group);
}

// CHECK-LABEL: define dso_local float @ff5(
// CHECK-SAME: ptr addrspace(1) noundef [[D:%.*]], double noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[D_ADDR:%.*]] = alloca ptr addrspace(1), align 8, addrspace(5)
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca double, align 8, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca double, align 8, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca double, align 8, addrspace(5)
// CHECK-NEXT:    store ptr addrspace(1) [[D]], ptr addrspace(5) [[D_ADDR]], align 8
// CHECK-NEXT:    store double [[A]], ptr addrspace(5) [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(1), ptr addrspace(5) [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load double, ptr addrspace(5) [[A_ADDR]], align 8
// CHECK-NEXT:    store double [[TMP1]], ptr addrspace(5) [[DOTATOMICTMP]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load double, ptr addrspace(5) [[DOTATOMICTMP]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = atomicrmw fadd ptr addrspace(1) [[TMP0]], double [[TMP2]] syncscope("workgroup-one-as") monotonic, align 8
// CHECK-NEXT:    store double [[TMP3]], ptr addrspace(5) [[ATOMIC_TEMP]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load double, ptr addrspace(5) [[ATOMIC_TEMP]], align 8
// CHECK-NEXT:    [[CONV:%.*]] = fptrunc double [[TMP4]] to float
// CHECK-NEXT:    ret float [[CONV]]
//
float ff5(global atomic_double *d, double a) {
  return __opencl_atomic_fetch_add(d, a, memory_order_relaxed, memory_scope_work_group);
}

// CHECK-LABEL: define dso_local void @atomic_init_foo(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    store i32 42, ptr addrspace(1) @j, align 4
// CHECK-NEXT:    ret void
//
void atomic_init_foo()
{
  __opencl_atomic_init(&j, 42);

}

// CHECK-LABEL: define dso_local void @failureOrder(
// CHECK-SAME: ptr noundef [[PTR:%.*]], ptr noundef [[PTR2:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[PTR_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[PTR2_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[CMPXCHG_BOOL:%.*]] = alloca i8, align 1, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP1:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[CMPXCHG_BOOL2:%.*]] = alloca i8, align 1, addrspace(5)
// CHECK-NEXT:    store ptr [[PTR]], ptr addrspace(5) [[PTR_ADDR]], align 8
// CHECK-NEXT:    store ptr [[PTR2]], ptr addrspace(5) [[PTR2_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr addrspace(5) [[PTR2_ADDR]], align 8
// CHECK-NEXT:    store i32 43, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[CMPXCHG_EXPECTED:%.*]] = load i32, ptr [[TMP1]], align 4
// CHECK-NEXT:    [[CMPXCHG_DESIRED:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[CMPXCHG_PAIR:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED]], i32 [[CMPXCHG_DESIRED]] syncscope("workgroup-one-as") acquire monotonic, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV]], ptr [[TMP1]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR]], 1
// CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr addrspace(5) [[CMPXCHG_BOOL]], align 1
// CHECK-NEXT:    [[LOADEDV:%.*]] = trunc i8 [[TMP2]] to i1
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr addrspace(5) [[PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr addrspace(5) [[PTR2_ADDR]], align 8
// CHECK-NEXT:    store i32 43, ptr addrspace(5) [[DOTATOMICTMP1]], align 4
// CHECK-NEXT:    [[CMPXCHG_EXPECTED3:%.*]] = load i32, ptr [[TMP4]], align 4
// CHECK-NEXT:    [[CMPXCHG_DESIRED4:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP1]], align 4
// CHECK-NEXT:    [[CMPXCHG_PAIR5:%.*]] = cmpxchg weak ptr [[TMP3]], i32 [[CMPXCHG_EXPECTED3]], i32 [[CMPXCHG_DESIRED4]] syncscope("workgroup") seq_cst acquire, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV6:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR5]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV6]], ptr [[TMP4]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS7:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR5]], 1
// CHECK-NEXT:    [[TMP5:%.*]] = load i8, ptr addrspace(5) [[CMPXCHG_BOOL2]], align 1
// CHECK-NEXT:    [[LOADEDV8:%.*]] = trunc i8 [[TMP5]] to i1
// CHECK-NEXT:    ret void
//
void failureOrder(atomic_int *ptr, int *ptr2) {
  __opencl_atomic_compare_exchange_strong(ptr, ptr2, 43, memory_order_acquire, memory_order_relaxed, memory_scope_work_group);

  __opencl_atomic_compare_exchange_weak(ptr, ptr2, 43, memory_order_seq_cst, memory_order_acquire, memory_scope_work_group);
}

// CHECK-LABEL: define dso_local void @generalFailureOrder(
// CHECK-SAME: ptr noundef [[PTR:%.*]], ptr noundef [[PTR2:%.*]], i32 noundef [[SUCCESS:%.*]], i32 noundef [[FAIL:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[PTR_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[PTR2_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[SUCCESS_ADDR:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[FAIL_ADDR:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    [[CMPXCHG_BOOL:%.*]] = alloca i8, align 1, addrspace(5)
// CHECK-NEXT:    store ptr [[PTR]], ptr addrspace(5) [[PTR_ADDR]], align 8
// CHECK-NEXT:    store ptr [[PTR2]], ptr addrspace(5) [[PTR2_ADDR]], align 8
// CHECK-NEXT:    store i32 [[SUCCESS]], ptr addrspace(5) [[SUCCESS_ADDR]], align 4
// CHECK-NEXT:    store i32 [[FAIL]], ptr addrspace(5) [[FAIL_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(5) [[SUCCESS_ADDR]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr addrspace(5) [[PTR2_ADDR]], align 8
// CHECK-NEXT:    store i32 42, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(5) [[FAIL_ADDR]], align 4
// CHECK-NEXT:    switch i32 [[TMP1]], label %[[MONOTONIC:.*]] [
// CHECK-NEXT:      i32 1, label %[[ACQUIRE:.*]]
// CHECK-NEXT:      i32 2, label %[[ACQUIRE]]
// CHECK-NEXT:      i32 3, label %[[RELEASE:.*]]
// CHECK-NEXT:      i32 4, label %[[ACQREL:.*]]
// CHECK-NEXT:      i32 5, label %[[SEQCST:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[MONOTONIC]]:
// CHECK-NEXT:    [[CMPXCHG_EXPECTED:%.*]] = load i32, ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_DESIRED:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    switch i32 [[TMP3]], label %[[MONOTONIC_FAIL:.*]] [
// CHECK-NEXT:      i32 1, label %[[ACQUIRE_FAIL:.*]]
// CHECK-NEXT:      i32 2, label %[[ACQUIRE_FAIL]]
// CHECK-NEXT:      i32 5, label %[[SEQCST_FAIL:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[ACQUIRE]]:
// CHECK-NEXT:    [[CMPXCHG_EXPECTED8:%.*]] = load i32, ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_DESIRED9:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    switch i32 [[TMP3]], label %[[MONOTONIC_FAIL10:.*]] [
// CHECK-NEXT:      i32 1, label %[[ACQUIRE_FAIL11:.*]]
// CHECK-NEXT:      i32 2, label %[[ACQUIRE_FAIL11]]
// CHECK-NEXT:      i32 5, label %[[SEQCST_FAIL12:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[RELEASE]]:
// CHECK-NEXT:    [[CMPXCHG_EXPECTED24:%.*]] = load i32, ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_DESIRED25:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    switch i32 [[TMP3]], label %[[MONOTONIC_FAIL26:.*]] [
// CHECK-NEXT:      i32 1, label %[[ACQUIRE_FAIL27:.*]]
// CHECK-NEXT:      i32 2, label %[[ACQUIRE_FAIL27]]
// CHECK-NEXT:      i32 5, label %[[SEQCST_FAIL28:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[ACQREL]]:
// CHECK-NEXT:    [[CMPXCHG_EXPECTED40:%.*]] = load i32, ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_DESIRED41:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    switch i32 [[TMP3]], label %[[MONOTONIC_FAIL42:.*]] [
// CHECK-NEXT:      i32 1, label %[[ACQUIRE_FAIL43:.*]]
// CHECK-NEXT:      i32 2, label %[[ACQUIRE_FAIL43]]
// CHECK-NEXT:      i32 5, label %[[SEQCST_FAIL44:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[SEQCST]]:
// CHECK-NEXT:    [[CMPXCHG_EXPECTED56:%.*]] = load i32, ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_DESIRED57:%.*]] = load i32, ptr addrspace(5) [[DOTATOMICTMP]], align 4
// CHECK-NEXT:    switch i32 [[TMP3]], label %[[MONOTONIC_FAIL58:.*]] [
// CHECK-NEXT:      i32 1, label %[[ACQUIRE_FAIL59:.*]]
// CHECK-NEXT:      i32 2, label %[[ACQUIRE_FAIL59]]
// CHECK-NEXT:      i32 5, label %[[SEQCST_FAIL60:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[ATOMIC_CONTINUE:.*]]:
// CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr addrspace(5) [[CMPXCHG_BOOL]], align 1
// CHECK-NEXT:    [[LOADEDV:%.*]] = trunc i8 [[TMP4]] to i1
// CHECK-NEXT:    ret void
// CHECK:       [[MONOTONIC_FAIL]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED]], i32 [[CMPXCHG_DESIRED]] syncscope("workgroup-one-as") monotonic monotonic, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE1:.*]]
// CHECK:       [[ACQUIRE_FAIL]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR2:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED]], i32 [[CMPXCHG_DESIRED]] syncscope("workgroup-one-as") monotonic acquire, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV3:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR2]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV3]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS4:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR2]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE1]]
// CHECK:       [[SEQCST_FAIL]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR5:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED]], i32 [[CMPXCHG_DESIRED]] syncscope("workgroup-one-as") monotonic seq_cst, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV6:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR5]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV6]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS7:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR5]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE1]]
// CHECK:       [[ATOMIC_CONTINUE1]]:
// CHECK-NEXT:    [[CMPXCGH_SUCCESS:%.*]] = phi i1 [ [[CMPXCHG_SUCCESS]], %[[MONOTONIC_FAIL]] ], [ [[CMPXCHG_SUCCESS4]], %[[ACQUIRE_FAIL]] ], [ [[CMPXCHG_SUCCESS7]], %[[SEQCST_FAIL]] ]
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE]]
// CHECK:       [[MONOTONIC_FAIL10]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR14:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED8]], i32 [[CMPXCHG_DESIRED9]] syncscope("workgroup-one-as") acquire monotonic, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV15:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR14]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV15]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS16:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR14]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE13:.*]]
// CHECK:       [[ACQUIRE_FAIL11]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR17:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED8]], i32 [[CMPXCHG_DESIRED9]] syncscope("workgroup-one-as") acquire acquire, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV18:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR17]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV18]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS19:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR17]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE13]]
// CHECK:       [[SEQCST_FAIL12]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR20:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED8]], i32 [[CMPXCHG_DESIRED9]] syncscope("workgroup-one-as") acquire seq_cst, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV21:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR20]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV21]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS22:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR20]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE13]]
// CHECK:       [[ATOMIC_CONTINUE13]]:
// CHECK-NEXT:    [[CMPXCGH_SUCCESS23:%.*]] = phi i1 [ [[CMPXCHG_SUCCESS16]], %[[MONOTONIC_FAIL10]] ], [ [[CMPXCHG_SUCCESS19]], %[[ACQUIRE_FAIL11]] ], [ [[CMPXCHG_SUCCESS22]], %[[SEQCST_FAIL12]] ]
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE]]
// CHECK:       [[MONOTONIC_FAIL26]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR30:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED24]], i32 [[CMPXCHG_DESIRED25]] syncscope("workgroup-one-as") release monotonic, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV31:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR30]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV31]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS32:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR30]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE29:.*]]
// CHECK:       [[ACQUIRE_FAIL27]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR33:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED24]], i32 [[CMPXCHG_DESIRED25]] syncscope("workgroup-one-as") release acquire, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV34:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR33]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV34]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS35:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR33]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE29]]
// CHECK:       [[SEQCST_FAIL28]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR36:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED24]], i32 [[CMPXCHG_DESIRED25]] syncscope("workgroup-one-as") release seq_cst, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV37:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR36]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV37]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS38:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR36]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE29]]
// CHECK:       [[ATOMIC_CONTINUE29]]:
// CHECK-NEXT:    [[CMPXCGH_SUCCESS39:%.*]] = phi i1 [ [[CMPXCHG_SUCCESS32]], %[[MONOTONIC_FAIL26]] ], [ [[CMPXCHG_SUCCESS35]], %[[ACQUIRE_FAIL27]] ], [ [[CMPXCHG_SUCCESS38]], %[[SEQCST_FAIL28]] ]
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE]]
// CHECK:       [[MONOTONIC_FAIL42]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR46:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED40]], i32 [[CMPXCHG_DESIRED41]] syncscope("workgroup-one-as") acq_rel monotonic, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV47:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR46]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV47]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS48:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR46]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE45:.*]]
// CHECK:       [[ACQUIRE_FAIL43]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR49:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED40]], i32 [[CMPXCHG_DESIRED41]] syncscope("workgroup-one-as") acq_rel acquire, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV50:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR49]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV50]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS51:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR49]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE45]]
// CHECK:       [[SEQCST_FAIL44]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR52:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED40]], i32 [[CMPXCHG_DESIRED41]] syncscope("workgroup-one-as") acq_rel seq_cst, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV53:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR52]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV53]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS54:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR52]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE45]]
// CHECK:       [[ATOMIC_CONTINUE45]]:
// CHECK-NEXT:    [[CMPXCGH_SUCCESS55:%.*]] = phi i1 [ [[CMPXCHG_SUCCESS48]], %[[MONOTONIC_FAIL42]] ], [ [[CMPXCHG_SUCCESS51]], %[[ACQUIRE_FAIL43]] ], [ [[CMPXCHG_SUCCESS54]], %[[SEQCST_FAIL44]] ]
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE]]
// CHECK:       [[MONOTONIC_FAIL58]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR62:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED56]], i32 [[CMPXCHG_DESIRED57]] syncscope("workgroup") seq_cst monotonic, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV63:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR62]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV63]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS64:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR62]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE61:.*]]
// CHECK:       [[ACQUIRE_FAIL59]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR65:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED56]], i32 [[CMPXCHG_DESIRED57]] syncscope("workgroup") seq_cst acquire, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV66:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR65]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV66]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS67:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR65]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE61]]
// CHECK:       [[SEQCST_FAIL60]]:
// CHECK-NEXT:    [[CMPXCHG_PAIR68:%.*]] = cmpxchg ptr [[TMP0]], i32 [[CMPXCHG_EXPECTED56]], i32 [[CMPXCHG_DESIRED57]] syncscope("workgroup") seq_cst seq_cst, align 4
// CHECK-NEXT:    [[CMPXCHG_PREV69:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR68]], 0
// CHECK-NEXT:    store i32 [[CMPXCHG_PREV69]], ptr [[TMP2]], align 4
// CHECK-NEXT:    [[CMPXCHG_SUCCESS70:%.*]] = extractvalue { i32, i1 } [[CMPXCHG_PAIR68]], 1
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE61]]
// CHECK:       [[ATOMIC_CONTINUE61]]:
// CHECK-NEXT:    [[CMPXCGH_SUCCESS71:%.*]] = phi i1 [ [[CMPXCHG_SUCCESS64]], %[[MONOTONIC_FAIL58]] ], [ [[CMPXCHG_SUCCESS67]], %[[ACQUIRE_FAIL59]] ], [ [[CMPXCHG_SUCCESS70]], %[[SEQCST_FAIL60]] ]
// CHECK-NEXT:    br label %[[ATOMIC_CONTINUE]]
//
void generalFailureOrder(atomic_int *ptr, int *ptr2, int success, int fail) {
  __opencl_atomic_compare_exchange_strong(ptr, ptr2, 42, success, fail, memory_scope_work_group);




















}

// CHECK-LABEL: define dso_local i32 @test_volatile(
// CHECK-SAME: ptr noundef [[I:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i32, align 4, addrspace(5)
// CHECK-NEXT:    store ptr [[I]], ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load atomic volatile i32, ptr [[TMP0]] syncscope("workgroup") seq_cst, align 4
// CHECK-NEXT:    store i32 [[TMP1]], ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(5) [[ATOMIC_TEMP]], align 4
// CHECK-NEXT:    ret i32 [[TMP2]]
//
int test_volatile(volatile atomic_int *i) {
  return __opencl_atomic_load(i, memory_order_seq_cst, memory_scope_work_group);
}

#endif
