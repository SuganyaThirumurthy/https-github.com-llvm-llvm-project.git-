; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc -mtriple=aarch64-linux-unknown -mattr=+sve -o - < %s | FileCheck %s

define i8 @clastb_i8(<vscale x 16 x i8> %data, <vscale x 16 x i1> %pg, i8 %existing) {
; CHECK-LABEL: clastb_i8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.b
; CHECK-NEXT:    rdvl x9, #1
; CHECK-NEXT:    rev p2.b, p0.b
; CHECK-NEXT:    brkb p1.b, p1/z, p2.b
; CHECK-NEXT:    cntp x8, p1, p1.b
; CHECK-NEXT:    mvn w8, w8
; CHECK-NEXT:    add w8, w8, w9
; CHECK-NEXT:    whilels p1.b, xzr, x8
; CHECK-NEXT:    ptest p0, p0.b
; CHECK-NEXT:    lastb w8, p1, z0.b
; CHECK-NEXT:    csel w0, w8, w0, ne
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 16 x i1> @llvm.vector.reverse.nxv16i1(<vscale x 16 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.i32.nxv16i1(<vscale x 16 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv16i1(<vscale x 16 x i1> %pg)
  %vscale = call i32 @llvm.vscale.i32()
  %size = shl i32 %vscale, 4
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 16 x i8> %data, i32 %idx
  %res = select i1 %any.set, i8 %extr, i8 %existing
  ret i8 %res
}

define i16 @clastb_i16(<vscale x 8 x i16> %data, <vscale x 8 x i1> %pg, i16 %existing) {
; CHECK-LABEL: clastb_i16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.h
; CHECK-NEXT:    cnth x9
; CHECK-NEXT:    rev p2.h, p0.h
; CHECK-NEXT:    brkb p1.b, p1/z, p2.b
; CHECK-NEXT:    cntp x8, p1, p1.h
; CHECK-NEXT:    mvn w8, w8
; CHECK-NEXT:    add w8, w8, w9
; CHECK-NEXT:    whilels p1.h, xzr, x8
; CHECK-NEXT:    lastb w8, p1, z0.h
; CHECK-NEXT:    ptrue p1.h
; CHECK-NEXT:    ptest p1, p0.b
; CHECK-NEXT:    csel w0, w8, w0, ne
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 8 x i1> @llvm.vector.reverse.nxv8i1(<vscale x 8 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.i32.nxv8i1(<vscale x 8 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv8i1(<vscale x 8 x i1> %pg)
  %vscale = call i32 @llvm.vscale.i32()
  %size = shl i32 %vscale, 3
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 8 x i16> %data, i32 %idx
  %res = select i1 %any.set, i16 %extr, i16 %existing
  ret i16 %res
}

define i32 @clastb_i32(<vscale x 4 x i32> %data, <vscale x 4 x i1> %pg, i32 %existing) {
; CHECK-LABEL: clastb_i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.s
; CHECK-NEXT:    cntw x9
; CHECK-NEXT:    rev p2.s, p0.s
; CHECK-NEXT:    brkb p1.b, p1/z, p2.b
; CHECK-NEXT:    cntp x8, p1, p1.s
; CHECK-NEXT:    mvn w8, w8
; CHECK-NEXT:    add w8, w8, w9
; CHECK-NEXT:    whilels p1.s, xzr, x8
; CHECK-NEXT:    lastb w8, p1, z0.s
; CHECK-NEXT:    ptrue p1.s
; CHECK-NEXT:    ptest p1, p0.b
; CHECK-NEXT:    csel w0, w8, w0, ne
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 4 x i1> @llvm.vector.reverse.nxv4i1(<vscale x 4 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.i32.nxv4i1(<vscale x 4 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> %pg)
  %vscale = call i32 @llvm.vscale.i32()
  %size = shl i32 %vscale, 2
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 4 x i32> %data, i32 %idx
  %res = select i1 %any.set, i32 %extr, i32 %existing
  ret i32 %res
}

define i64 @clastb_i64(<vscale x 2 x i64> %data, <vscale x 2 x i1> %pg, i64 %existing) {
; CHECK-LABEL: clastb_i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.d
; CHECK-NEXT:    cntd x9
; CHECK-NEXT:    rev p2.d, p0.d
; CHECK-NEXT:    brkb p1.b, p1/z, p2.b
; CHECK-NEXT:    cntp x8, p1, p1.d
; CHECK-NEXT:    mvn w8, w8
; CHECK-NEXT:    add w8, w8, w9
; CHECK-NEXT:    whilels p1.d, xzr, x8
; CHECK-NEXT:    lastb x8, p1, z0.d
; CHECK-NEXT:    ptrue p1.d
; CHECK-NEXT:    ptest p1, p0.b
; CHECK-NEXT:    csel x0, x8, x0, ne
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 2 x i1> @llvm.vector.reverse.nxv2i1(<vscale x 2 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.i32.nxv2i1(<vscale x 2 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv2i1(<vscale x 2 x i1> %pg)
  %vscale = call i32 @llvm.vscale.i32()
  %size = shl i32 %vscale, 1
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 2 x i64> %data, i32 %idx
  %res = select i1 %any.set, i64 %extr, i64 %existing
  ret i64 %res
}

define float @clastb_float(<vscale x 4 x float> %data, <vscale x 4 x i1> %pg, float %existing) {
; CHECK-LABEL: clastb_float:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.s
; CHECK-NEXT:    cntw x9
; CHECK-NEXT:    rev p2.s, p0.s
; CHECK-NEXT:    brkb p1.b, p1/z, p2.b
; CHECK-NEXT:    cntp x8, p1, p1.s
; CHECK-NEXT:    mvn w8, w8
; CHECK-NEXT:    add w8, w8, w9
; CHECK-NEXT:    whilels p1.s, xzr, x8
; CHECK-NEXT:    lastb s0, p1, z0.s
; CHECK-NEXT:    ptrue p1.s
; CHECK-NEXT:    ptest p1, p0.b
; CHECK-NEXT:    fcsel s0, s0, s1, ne
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 4 x i1> @llvm.vector.reverse.nxv4i1(<vscale x 4 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.float.nxv4i1(<vscale x 4 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv4i1(<vscale x 4 x i1> %pg)
  %vscale = call i32 @llvm.vscale.float()
  %size = shl i32 %vscale, 2
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 4 x float> %data, i32 %idx
  %res = select i1 %any.set, float %extr, float %existing
  ret float %res
}

define double @clastb_double(<vscale x 2 x double> %data, <vscale x 2 x i1> %pg, double %existing) {
; CHECK-LABEL: clastb_double:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.d
; CHECK-NEXT:    cntd x9
; CHECK-NEXT:    rev p2.d, p0.d
; CHECK-NEXT:    brkb p1.b, p1/z, p2.b
; CHECK-NEXT:    cntp x8, p1, p1.d
; CHECK-NEXT:    mvn w8, w8
; CHECK-NEXT:    add w8, w8, w9
; CHECK-NEXT:    whilels p1.d, xzr, x8
; CHECK-NEXT:    lastb d0, p1, z0.d
; CHECK-NEXT:    ptrue p1.d
; CHECK-NEXT:    ptest p1, p0.b
; CHECK-NEXT:    fcsel d0, d0, d1, ne
; CHECK-NEXT:    ret
  %rev.pg = call <vscale x 2 x i1> @llvm.vector.reverse.nxv2i1(<vscale x 2 x i1> %pg)
  %tz.cnt = call i32 @llvm.experimental.cttz.elts.i32.nxv2i1(<vscale x 2 x i1> %rev.pg, i1 false)
  %any.set = call i1 @llvm.vector.reduce.or.nxv2i1(<vscale x 2 x i1> %pg)
  %vscale = call i32 @llvm.vscale.i32()
  %size = shl i32 %vscale, 1
  %sub = sub i32 %size, %tz.cnt
  %idx = sub i32 %sub, 1
  %extr = extractelement <vscale x 2 x double> %data, i32 %idx
  %res = select i1 %any.set, double %extr, double %existing
  ret double %res
}
