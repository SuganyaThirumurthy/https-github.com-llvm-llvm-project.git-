; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -msan-check-access-address=0 -S -passes=msan 2>&1 | FileCheck  \
; RUN: %s
; RUN: opt < %s -msan-check-access-address=0 -msan-track-origins=1 -S          \
; RUN: -passes=msan 2>&1 | FileCheck %s --check-prefixes=CHECK,CHECK-ORIGIN
; RUN: opt < %s -msan-check-access-address=0 -S          \
; RUN: -passes="msan<track-origins=1>" 2>&1 | FileCheck %s --check-prefixes=CHECK,CHECK-ORIGIN
; RUN: opt < %s -msan-check-access-address=0 -msan-track-origins=2 -S          \
; RUN: -passes=msan 2>&1 | FileCheck %s --check-prefixes=CHECK,CHECK-ORIGIN

; Test that shadow and origin are stored for variadic function params.

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.__va_list_tag = type { i32, i32, ptr, ptr }

define dso_local i32 @test(i32 %a, i32 %b, i32 %c) local_unnamed_addr {
; CHECK-ORIGIN-LABEL: define dso_local i32 @test(
; CHECK-ORIGIN-SAME: i32 [[A:%.*]], i32 [[B:%.*]], i32 [[C:%.*]]) local_unnamed_addr {
; CHECK-ORIGIN-NEXT:  [[ENTRY:.*:]]
; CHECK-ORIGIN-NEXT:    call void @llvm.donothing()
; CHECK-ORIGIN-NEXT:    store i32 0, ptr @__msan_param_tls, align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 8) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 16) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 24) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 8) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 8) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 16) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 16) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 24) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 24) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i64 0, ptr @__msan_va_arg_overflow_size_tls, align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN-NEXT:    [[CALL:%.*]] = tail call i32 (i32, ...) @sum(i32 3, i32 [[A]], i32 [[B]], i32 [[C]])
; CHECK-ORIGIN-NEXT:    [[_MSRET:%.*]] = load i32, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN-NEXT:    [[TMP0:%.*]] = load i32, ptr @__msan_retval_origin_tls, align 4
; CHECK-ORIGIN-NEXT:    store i32 0, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr @__msan_retval_origin_tls, align 4
; CHECK-ORIGIN-NEXT:    ret i32 [[CALL]]
;
; CHECK-ORIGIN"-LABEL: define dso_local i32 @test(
; CHECK-ORIGIN"-SAME: i32 [[A:%.*]], i32 [[B:%.*]], i32 [[C:%.*]]) local_unnamed_addr {
; CHECK-ORIGIN"-NEXT:  [[ENTRY:.*:]]
; CHECK-ORIGIN"-NEXT:    call void @llvm.donothing()
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr @__msan_param_tls, align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 8) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 16) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 24) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 8) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 8) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 16) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 16) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 24) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 24) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i64 0, ptr @__msan_va_arg_overflow_size_tls, align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN"-NEXT:    [[CALL:%.*]] = tail call i32 (i32, ...) @sum(i32 3, i32 [[A]], i32 [[B]], i32 [[C]])
; CHECK-ORIGIN"-NEXT:    [[_MSRET:%.*]] = load i32, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN"-NEXT:    [[TMP0:%.*]] = load i32, ptr @__msan_retval_origin_tls, align 4
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr @__msan_retval_origin_tls, align 4
; CHECK-ORIGIN"-NEXT:    ret i32 [[CALL]]
entry:
  %call = tail call i32 (i32, ...) @sum(i32 3, i32 %a, i32 %b, i32 %c)
  ret i32 %call
}


define dso_local i32 @sum(i32 %n, ...) local_unnamed_addr #0 {
; CHECK-ORIGIN-LABEL: define dso_local i32 @sum(
; CHECK-ORIGIN-SAME: i32 [[N:%.*]], ...) local_unnamed_addr {
; CHECK-ORIGIN-NEXT:  [[ENTRY:.*]]:
; CHECK-ORIGIN-NEXT:    [[TMP0:%.*]] = load i64, ptr @__msan_va_arg_overflow_size_tls, align 8
; CHECK-ORIGIN-NEXT:    [[TMP1:%.*]] = add i64 176, [[TMP0]]
; CHECK-ORIGIN-NEXT:    [[TMP2:%.*]] = alloca i8, i64 [[TMP1]], align 8
; CHECK-ORIGIN-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 [[TMP1]], i1 false)
; CHECK-ORIGIN-NEXT:    [[TMP3:%.*]] = call i64 @llvm.umin.i64(i64 [[TMP1]], i64 800)
; CHECK-ORIGIN-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[TMP2]], ptr align 8 @__msan_va_arg_tls, i64 [[TMP3]], i1 false)
; CHECK-ORIGIN-NEXT:    [[TMP4:%.*]] = alloca i8, i64 [[TMP1]], align 8
; CHECK-ORIGIN-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[TMP4]], ptr align 8 @__msan_va_arg_origin_tls, i64 [[TMP3]], i1 false)
; CHECK-ORIGIN-NEXT:    call void @llvm.donothing()
; CHECK-ORIGIN-NEXT:    [[ARGS:%.*]] = alloca [1 x %struct.__va_list_tag], align 16
; CHECK-ORIGIN-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[ARGS]] to i64
; CHECK-ORIGIN-NEXT:    [[TMP6:%.*]] = xor i64 [[TMP5]], 87960930222080
; CHECK-ORIGIN-NEXT:    [[TMP7:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-ORIGIN-NEXT:    [[TMP8:%.*]] = add i64 [[TMP6]], 17592186044416
; CHECK-ORIGIN-NEXT:    [[TMP9:%.*]] = and i64 [[TMP8]], -4
; CHECK-ORIGIN-NEXT:    [[TMP10:%.*]] = inttoptr i64 [[TMP9]] to ptr
; CHECK-ORIGIN-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP7]], i8 0, i64 24, i1 false)
; CHECK-ORIGIN-NEXT:    call void @llvm.lifetime.start.p0(i64 24, ptr nonnull [[ARGS]])
; CHECK-ORIGIN-NEXT:    [[TMP11:%.*]] = ptrtoint ptr [[ARGS]] to i64
; CHECK-ORIGIN-NEXT:    [[TMP12:%.*]] = xor i64 [[TMP11]], 87960930222080
; CHECK-ORIGIN-NEXT:    [[TMP13:%.*]] = inttoptr i64 [[TMP12]] to ptr
; CHECK-ORIGIN-NEXT:    [[TMP14:%.*]] = add i64 [[TMP12]], 17592186044416
; CHECK-ORIGIN-NEXT:    [[TMP15:%.*]] = inttoptr i64 [[TMP14]] to ptr
; CHECK-ORIGIN-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP13]], i8 0, i64 24, i1 false)
; CHECK-ORIGIN-NEXT:    call void @llvm.va_start.p0(ptr nonnull [[ARGS]])
; CHECK-ORIGIN-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[ARGS]] to i64
; CHECK-ORIGIN-NEXT:    [[TMP17:%.*]] = add i64 [[TMP16]], 16
; CHECK-ORIGIN-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
; CHECK-ORIGIN-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[TMP18]], align 8
; CHECK-ORIGIN-NEXT:    [[TMP20:%.*]] = ptrtoint ptr [[TMP19]] to i64
; CHECK-ORIGIN-NEXT:    [[TMP21:%.*]] = xor i64 [[TMP20]], 87960930222080
; CHECK-ORIGIN-NEXT:    [[TMP22:%.*]] = inttoptr i64 [[TMP21]] to ptr
; CHECK-ORIGIN-NEXT:    [[TMP23:%.*]] = add i64 [[TMP21]], 17592186044416
; CHECK-ORIGIN-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
; CHECK-ORIGIN-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[TMP22]], ptr align 16 [[TMP2]], i64 176, i1 false)
; CHECK-ORIGIN-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[TMP24]], ptr align 16 [[TMP4]], i64 176, i1 false)
; CHECK-ORIGIN-NEXT:    [[TMP25:%.*]] = ptrtoint ptr [[ARGS]] to i64
; CHECK-ORIGIN-NEXT:    [[TMP26:%.*]] = add i64 [[TMP25]], 8
; CHECK-ORIGIN-NEXT:    [[TMP27:%.*]] = inttoptr i64 [[TMP26]] to ptr
; CHECK-ORIGIN-NEXT:    [[TMP28:%.*]] = load ptr, ptr [[TMP27]], align 8
; CHECK-ORIGIN-NEXT:    [[TMP29:%.*]] = ptrtoint ptr [[TMP28]] to i64
; CHECK-ORIGIN-NEXT:    [[TMP30:%.*]] = xor i64 [[TMP29]], 87960930222080
; CHECK-ORIGIN-NEXT:    [[TMP31:%.*]] = inttoptr i64 [[TMP30]] to ptr
; CHECK-ORIGIN-NEXT:    [[TMP32:%.*]] = add i64 [[TMP30]], 17592186044416
; CHECK-ORIGIN-NEXT:    [[TMP33:%.*]] = inttoptr i64 [[TMP32]] to ptr
; CHECK-ORIGIN-NEXT:    [[TMP34:%.*]] = getelementptr i8, ptr [[TMP2]], i32 176
; CHECK-ORIGIN-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[TMP31]], ptr align 16 [[TMP34]], i64 [[TMP0]], i1 false)
; CHECK-ORIGIN-NEXT:    [[TMP35:%.*]] = getelementptr i8, ptr [[TMP4]], i32 176
; CHECK-ORIGIN-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[TMP33]], ptr align 16 [[TMP35]], i64 [[TMP0]], i1 false)
; CHECK-ORIGIN-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-ORIGIN-NEXT:    br i1 [[CMP9]], label %[[FOR_BODY_LR_PH:.*]], label %[[FOR_END:.*]]
; CHECK-ORIGIN:       [[FOR_BODY_LR_PH]]:
; CHECK-ORIGIN-NEXT:    [[TMP36:%.*]] = getelementptr inbounds [1 x %struct.__va_list_tag], ptr [[ARGS]], i64 0, i64 0, i32 3
; CHECK-ORIGIN-NEXT:    [[OVERFLOW_ARG_AREA_P:%.*]] = getelementptr inbounds [1 x %struct.__va_list_tag], ptr [[ARGS]], i64 0, i64 0, i32 2
; CHECK-ORIGIN-NEXT:    [[GP_OFFSET_PRE:%.*]] = load i32, ptr [[ARGS]], align 16
; CHECK-ORIGIN-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK-ORIGIN:       [[FOR_BODY]]:
; CHECK-ORIGIN-NEXT:    [[GP_OFFSET:%.*]] = phi i32 [ [[GP_OFFSET_PRE]], %[[FOR_BODY_LR_PH]] ], [ [[GP_OFFSET12:%.*]], %[[VAARG_END:.*]] ]
; CHECK-ORIGIN-NEXT:    [[SUM_011:%.*]] = phi i32 [ 0, %[[FOR_BODY_LR_PH]] ], [ [[ADD:%.*]], %[[VAARG_END]] ]
; CHECK-ORIGIN-NEXT:    [[I_010:%.*]] = phi i32 [ 0, %[[FOR_BODY_LR_PH]] ], [ [[INC:%.*]], %[[VAARG_END]] ]
; CHECK-ORIGIN-NEXT:    [[TMP37:%.*]] = and i32 [[GP_OFFSET]], -1
; CHECK-ORIGIN-NEXT:    [[TMP38:%.*]] = icmp ult i32 [[TMP37]], 41
; CHECK-ORIGIN-NEXT:    [[TMP39:%.*]] = or i32 [[GP_OFFSET]], 0
; CHECK-ORIGIN-NEXT:    [[TMP40:%.*]] = icmp ult i32 [[TMP39]], 41
; CHECK-ORIGIN-NEXT:    [[TMP41:%.*]] = xor i1 [[TMP38]], [[TMP40]]
; CHECK-ORIGIN-NEXT:    [[FITS_IN_GP:%.*]] = icmp ult i32 [[GP_OFFSET]], 41
; CHECK-ORIGIN-NEXT:    br i1 [[FITS_IN_GP]], label %[[VAARG_IN_REG:.*]], label %[[VAARG_IN_MEM:.*]]
; CHECK-ORIGIN:       [[VAARG_IN_REG]]:
; CHECK-ORIGIN-NEXT:    [[REG_SAVE_AREA:%.*]] = load ptr, ptr [[TMP36]], align 16
; CHECK-ORIGIN-NEXT:    [[TMP42:%.*]] = sext i32 [[GP_OFFSET]] to i64
; CHECK-ORIGIN-NEXT:    [[TMP43:%.*]] = getelementptr i8, ptr [[REG_SAVE_AREA]], i64 [[TMP42]]
; CHECK-ORIGIN-NEXT:    [[TMP44:%.*]] = add i32 [[GP_OFFSET]], 8
; CHECK-ORIGIN-NEXT:    [[TMP45:%.*]] = ptrtoint ptr [[ARGS]] to i64
; CHECK-ORIGIN-NEXT:    [[TMP46:%.*]] = xor i64 [[TMP45]], 87960930222080
; CHECK-ORIGIN-NEXT:    [[TMP47:%.*]] = inttoptr i64 [[TMP46]] to ptr
; CHECK-ORIGIN-NEXT:    [[TMP48:%.*]] = add i64 [[TMP46]], 17592186044416
; CHECK-ORIGIN-NEXT:    [[TMP49:%.*]] = inttoptr i64 [[TMP48]] to ptr
; CHECK-ORIGIN-NEXT:    store i32 0, ptr [[TMP47]], align 16
; CHECK-ORIGIN-NEXT:    store i32 [[TMP44]], ptr [[ARGS]], align 16
; CHECK-ORIGIN-NEXT:    br label %[[VAARG_END]]
; CHECK-ORIGIN:       [[VAARG_IN_MEM]]:
; CHECK-ORIGIN-NEXT:    [[OVERFLOW_ARG_AREA:%.*]] = load ptr, ptr [[OVERFLOW_ARG_AREA_P]], align 8
; CHECK-ORIGIN-NEXT:    [[OVERFLOW_ARG_AREA_NEXT:%.*]] = getelementptr i8, ptr [[OVERFLOW_ARG_AREA]], i64 8
; CHECK-ORIGIN-NEXT:    [[TMP50:%.*]] = ptrtoint ptr [[OVERFLOW_ARG_AREA_P]] to i64
; CHECK-ORIGIN-NEXT:    [[TMP51:%.*]] = xor i64 [[TMP50]], 87960930222080
; CHECK-ORIGIN-NEXT:    [[TMP52:%.*]] = inttoptr i64 [[TMP51]] to ptr
; CHECK-ORIGIN-NEXT:    [[TMP53:%.*]] = add i64 [[TMP51]], 17592186044416
; CHECK-ORIGIN-NEXT:    [[TMP54:%.*]] = inttoptr i64 [[TMP53]] to ptr
; CHECK-ORIGIN-NEXT:    store i64 0, ptr [[TMP52]], align 8
; CHECK-ORIGIN-NEXT:    store ptr [[OVERFLOW_ARG_AREA_NEXT]], ptr [[OVERFLOW_ARG_AREA_P]], align 8
; CHECK-ORIGIN-NEXT:    br label %[[VAARG_END]]
; CHECK-ORIGIN:       [[VAARG_END]]:
; CHECK-ORIGIN-NEXT:    [[GP_OFFSET12]] = phi i32 [ [[TMP44]], %[[VAARG_IN_REG]] ], [ [[GP_OFFSET]], %[[VAARG_IN_MEM]] ]
; CHECK-ORIGIN-NEXT:    [[VAARG_ADDR_IN:%.*]] = phi ptr [ [[TMP43]], %[[VAARG_IN_REG]] ], [ [[OVERFLOW_ARG_AREA]], %[[VAARG_IN_MEM]] ]
; CHECK-ORIGIN-NEXT:    [[TMP55:%.*]] = load i32, ptr [[VAARG_ADDR_IN]], align 4
; CHECK-ORIGIN-NEXT:    [[ADD]] = add nsw i32 [[TMP55]], [[SUM_011]]
; CHECK-ORIGIN-NEXT:    [[INC]] = add nuw nsw i32 [[I_010]], 1
; CHECK-ORIGIN-NEXT:    [[TMP56:%.*]] = xor i32 [[INC]], [[N]]
; CHECK-ORIGIN-NEXT:    [[TMP57:%.*]] = and i32 -1, [[TMP56]]
; CHECK-ORIGIN-NEXT:    [[TMP58:%.*]] = icmp eq i32 [[TMP57]], 0
; CHECK-ORIGIN-NEXT:    [[_MSPROP_ICMP:%.*]] = and i1 false, [[TMP58]]
; CHECK-ORIGIN-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC]], [[N]]
; CHECK-ORIGIN-NEXT:    br i1 [[EXITCOND]], label %[[FOR_END]], label %[[FOR_BODY]]
; CHECK-ORIGIN:       [[FOR_END]]:
; CHECK-ORIGIN-NEXT:    [[SUM_0_LCSSA:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[ADD]], %[[VAARG_END]] ]
; CHECK-ORIGIN-NEXT:    call void @llvm.va_end.p0(ptr nonnull [[ARGS]])
; CHECK-ORIGIN-NEXT:    call void @llvm.lifetime.end.p0(i64 24, ptr nonnull [[ARGS]])
; CHECK-ORIGIN-NEXT:    store i32 0, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr @__msan_retval_origin_tls, align 4
; CHECK-ORIGIN-NEXT:    ret i32 [[SUM_0_LCSSA]]
;
; CHECK-ORIGIN"-LABEL: define dso_local i32 @sum(
; CHECK-ORIGIN"-SAME: i32 [[N:%.*]], ...) local_unnamed_addr {
; CHECK-ORIGIN"-NEXT:  [[ENTRY:.*]]:
; CHECK-ORIGIN"-NEXT:    [[TMP0:%.*]] = load i64, ptr @__msan_va_arg_overflow_size_tls, align 8
; CHECK-ORIGIN"-NEXT:    [[TMP1:%.*]] = add i64 176, [[TMP0]]
; CHECK-ORIGIN"-NEXT:    [[TMP2:%.*]] = alloca i8, i64 [[TMP1]], align 8
; CHECK-ORIGIN"-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP2]], i8 0, i64 [[TMP1]], i1 false)
; CHECK-ORIGIN"-NEXT:    [[TMP3:%.*]] = call i64 @llvm.umin.i64(i64 [[TMP1]], i64 800)
; CHECK-ORIGIN"-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[TMP2]], ptr align 8 @__msan_va_arg_tls, i64 [[TMP3]], i1 false)
; CHECK-ORIGIN"-NEXT:    [[TMP4:%.*]] = alloca i8, i64 [[TMP1]], align 8
; CHECK-ORIGIN"-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[TMP4]], ptr align 8 @__msan_va_arg_origin_tls, i64 [[TMP3]], i1 false)
; CHECK-ORIGIN"-NEXT:    call void @llvm.donothing()
; CHECK-ORIGIN"-NEXT:    [[ARGS:%.*]] = alloca [1 x %struct.__va_list_tag], align 16
; CHECK-ORIGIN"-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[ARGS]] to i64
; CHECK-ORIGIN"-NEXT:    [[TMP6:%.*]] = xor i64 [[TMP5]], 87960930222080
; CHECK-ORIGIN"-NEXT:    [[TMP7:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-ORIGIN"-NEXT:    [[TMP8:%.*]] = add i64 [[TMP6]], 17592186044416
; CHECK-ORIGIN"-NEXT:    [[TMP9:%.*]] = and i64 [[TMP8]], -4
; CHECK-ORIGIN"-NEXT:    [[TMP10:%.*]] = inttoptr i64 [[TMP9]] to ptr
; CHECK-ORIGIN"-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[TMP7]], i8 0, i64 24, i1 false)
; CHECK-ORIGIN"-NEXT:    call void @llvm.lifetime.start.p0(i64 24, ptr nonnull [[ARGS]])
; CHECK-ORIGIN"-NEXT:    [[TMP11:%.*]] = ptrtoint ptr [[ARGS]] to i64
; CHECK-ORIGIN"-NEXT:    [[TMP12:%.*]] = xor i64 [[TMP11]], 87960930222080
; CHECK-ORIGIN"-NEXT:    [[TMP13:%.*]] = inttoptr i64 [[TMP12]] to ptr
; CHECK-ORIGIN"-NEXT:    [[TMP14:%.*]] = add i64 [[TMP12]], 17592186044416
; CHECK-ORIGIN"-NEXT:    [[TMP15:%.*]] = inttoptr i64 [[TMP14]] to ptr
; CHECK-ORIGIN"-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[TMP13]], i8 0, i64 24, i1 false)
; CHECK-ORIGIN"-NEXT:    call void @llvm.va_start.p0(ptr nonnull [[ARGS]])
; CHECK-ORIGIN"-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[ARGS]] to i64
; CHECK-ORIGIN"-NEXT:    [[TMP17:%.*]] = add i64 [[TMP16]], 16
; CHECK-ORIGIN"-NEXT:    [[TMP18:%.*]] = inttoptr i64 [[TMP17]] to ptr
; CHECK-ORIGIN"-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[TMP18]], align 8
; CHECK-ORIGIN"-NEXT:    [[TMP20:%.*]] = ptrtoint ptr [[TMP19]] to i64
; CHECK-ORIGIN"-NEXT:    [[TMP21:%.*]] = xor i64 [[TMP20]], 87960930222080
; CHECK-ORIGIN"-NEXT:    [[TMP22:%.*]] = inttoptr i64 [[TMP21]] to ptr
; CHECK-ORIGIN"-NEXT:    [[TMP23:%.*]] = add i64 [[TMP21]], 17592186044416
; CHECK-ORIGIN"-NEXT:    [[TMP24:%.*]] = inttoptr i64 [[TMP23]] to ptr
; CHECK-ORIGIN"-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[TMP22]], ptr align 16 [[TMP2]], i64 176, i1 false)
; CHECK-ORIGIN"-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[TMP24]], ptr align 16 [[TMP4]], i64 176, i1 false)
; CHECK-ORIGIN"-NEXT:    [[TMP25:%.*]] = ptrtoint ptr [[ARGS]] to i64
; CHECK-ORIGIN"-NEXT:    [[TMP26:%.*]] = add i64 [[TMP25]], 8
; CHECK-ORIGIN"-NEXT:    [[TMP27:%.*]] = inttoptr i64 [[TMP26]] to ptr
; CHECK-ORIGIN"-NEXT:    [[TMP28:%.*]] = load ptr, ptr [[TMP27]], align 8
; CHECK-ORIGIN"-NEXT:    [[TMP29:%.*]] = ptrtoint ptr [[TMP28]] to i64
; CHECK-ORIGIN"-NEXT:    [[TMP30:%.*]] = xor i64 [[TMP29]], 87960930222080
; CHECK-ORIGIN"-NEXT:    [[TMP31:%.*]] = inttoptr i64 [[TMP30]] to ptr
; CHECK-ORIGIN"-NEXT:    [[TMP32:%.*]] = add i64 [[TMP30]], 17592186044416
; CHECK-ORIGIN"-NEXT:    [[TMP33:%.*]] = inttoptr i64 [[TMP32]] to ptr
; CHECK-ORIGIN"-NEXT:    [[TMP34:%.*]] = getelementptr i8, ptr [[TMP2]], i32 176
; CHECK-ORIGIN"-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[TMP31]], ptr align 16 [[TMP34]], i64 [[TMP0]], i1 false)
; CHECK-ORIGIN"-NEXT:    [[TMP35:%.*]] = getelementptr i8, ptr [[TMP4]], i32 176
; CHECK-ORIGIN"-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[TMP33]], ptr align 16 [[TMP35]], i64 [[TMP0]], i1 false)
; CHECK-ORIGIN"-NEXT:    [[CMP9:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-ORIGIN"-NEXT:    br i1 [[CMP9]], label %[[FOR_BODY_LR_PH:.*]], label %[[FOR_END:.*]]
; CHECK-ORIGIN":       [[FOR_BODY_LR_PH]]:
; CHECK-ORIGIN"-NEXT:    [[TMP36:%.*]] = getelementptr inbounds [1 x %struct.__va_list_tag], ptr [[ARGS]], i64 0, i64 0, i32 3
; CHECK-ORIGIN"-NEXT:    [[OVERFLOW_ARG_AREA_P:%.*]] = getelementptr inbounds [1 x %struct.__va_list_tag], ptr [[ARGS]], i64 0, i64 0, i32 2
; CHECK-ORIGIN"-NEXT:    [[GP_OFFSET_PRE:%.*]] = load i32, ptr [[ARGS]], align 16
; CHECK-ORIGIN"-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK-ORIGIN":       [[FOR_BODY]]:
; CHECK-ORIGIN"-NEXT:    [[GP_OFFSET:%.*]] = phi i32 [ [[GP_OFFSET_PRE]], %[[FOR_BODY_LR_PH]] ], [ [[GP_OFFSET12:%.*]], %[[VAARG_END:.*]] ]
; CHECK-ORIGIN"-NEXT:    [[SUM_011:%.*]] = phi i32 [ 0, %[[FOR_BODY_LR_PH]] ], [ [[ADD:%.*]], %[[VAARG_END]] ]
; CHECK-ORIGIN"-NEXT:    [[I_010:%.*]] = phi i32 [ 0, %[[FOR_BODY_LR_PH]] ], [ [[INC:%.*]], %[[VAARG_END]] ]
; CHECK-ORIGIN"-NEXT:    [[TMP37:%.*]] = and i32 [[GP_OFFSET]], -1
; CHECK-ORIGIN"-NEXT:    [[TMP38:%.*]] = icmp ult i32 [[TMP37]], 41
; CHECK-ORIGIN"-NEXT:    [[TMP39:%.*]] = or i32 [[GP_OFFSET]], 0
; CHECK-ORIGIN"-NEXT:    [[TMP40:%.*]] = icmp ult i32 [[TMP39]], 41
; CHECK-ORIGIN"-NEXT:    [[TMP41:%.*]] = xor i1 [[TMP38]], [[TMP40]]
; CHECK-ORIGIN"-NEXT:    [[FITS_IN_GP:%.*]] = icmp ult i32 [[GP_OFFSET]], 41
; CHECK-ORIGIN"-NEXT:    br i1 [[FITS_IN_GP]], label %[[VAARG_IN_REG:.*]], label %[[VAARG_IN_MEM:.*]]
; CHECK-ORIGIN":       [[VAARG_IN_REG]]:
; CHECK-ORIGIN"-NEXT:    [[REG_SAVE_AREA:%.*]] = load ptr, ptr [[TMP36]], align 16
; CHECK-ORIGIN"-NEXT:    [[TMP42:%.*]] = sext i32 [[GP_OFFSET]] to i64
; CHECK-ORIGIN"-NEXT:    [[TMP43:%.*]] = getelementptr i8, ptr [[REG_SAVE_AREA]], i64 [[TMP42]]
; CHECK-ORIGIN"-NEXT:    [[TMP44:%.*]] = add i32 [[GP_OFFSET]], 8
; CHECK-ORIGIN"-NEXT:    [[TMP45:%.*]] = ptrtoint ptr [[ARGS]] to i64
; CHECK-ORIGIN"-NEXT:    [[TMP46:%.*]] = xor i64 [[TMP45]], 87960930222080
; CHECK-ORIGIN"-NEXT:    [[TMP47:%.*]] = inttoptr i64 [[TMP46]] to ptr
; CHECK-ORIGIN"-NEXT:    [[TMP48:%.*]] = add i64 [[TMP46]], 17592186044416
; CHECK-ORIGIN"-NEXT:    [[TMP49:%.*]] = inttoptr i64 [[TMP48]] to ptr
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr [[TMP47]], align 16
; CHECK-ORIGIN"-NEXT:    store i32 [[TMP44]], ptr [[ARGS]], align 16
; CHECK-ORIGIN"-NEXT:    br label %[[VAARG_END]]
; CHECK-ORIGIN":       [[VAARG_IN_MEM]]:
; CHECK-ORIGIN"-NEXT:    [[OVERFLOW_ARG_AREA:%.*]] = load ptr, ptr [[OVERFLOW_ARG_AREA_P]], align 8
; CHECK-ORIGIN"-NEXT:    [[OVERFLOW_ARG_AREA_NEXT:%.*]] = getelementptr i8, ptr [[OVERFLOW_ARG_AREA]], i64 8
; CHECK-ORIGIN"-NEXT:    [[TMP50:%.*]] = ptrtoint ptr [[OVERFLOW_ARG_AREA_P]] to i64
; CHECK-ORIGIN"-NEXT:    [[TMP51:%.*]] = xor i64 [[TMP50]], 87960930222080
; CHECK-ORIGIN"-NEXT:    [[TMP52:%.*]] = inttoptr i64 [[TMP51]] to ptr
; CHECK-ORIGIN"-NEXT:    [[TMP53:%.*]] = add i64 [[TMP51]], 17592186044416
; CHECK-ORIGIN"-NEXT:    [[TMP54:%.*]] = inttoptr i64 [[TMP53]] to ptr
; CHECK-ORIGIN"-NEXT:    store i64 0, ptr [[TMP52]], align 8
; CHECK-ORIGIN"-NEXT:    store ptr [[OVERFLOW_ARG_AREA_NEXT]], ptr [[OVERFLOW_ARG_AREA_P]], align 8
; CHECK-ORIGIN"-NEXT:    br label %[[VAARG_END]]
; CHECK-ORIGIN":       [[VAARG_END]]:
; CHECK-ORIGIN"-NEXT:    [[GP_OFFSET12]] = phi i32 [ [[TMP44]], %[[VAARG_IN_REG]] ], [ [[GP_OFFSET]], %[[VAARG_IN_MEM]] ]
; CHECK-ORIGIN"-NEXT:    [[VAARG_ADDR_IN:%.*]] = phi ptr [ [[TMP43]], %[[VAARG_IN_REG]] ], [ [[OVERFLOW_ARG_AREA]], %[[VAARG_IN_MEM]] ]
; CHECK-ORIGIN"-NEXT:    [[TMP55:%.*]] = load i32, ptr [[VAARG_ADDR_IN]], align 4
; CHECK-ORIGIN"-NEXT:    [[ADD]] = add nsw i32 [[TMP55]], [[SUM_011]]
; CHECK-ORIGIN"-NEXT:    [[INC]] = add nuw nsw i32 [[I_010]], 1
; CHECK-ORIGIN"-NEXT:    [[TMP56:%.*]] = xor i32 [[INC]], [[N]]
; CHECK-ORIGIN"-NEXT:    [[TMP57:%.*]] = and i32 -1, [[TMP56]]
; CHECK-ORIGIN"-NEXT:    [[TMP58:%.*]] = icmp eq i32 [[TMP57]], 0
; CHECK-ORIGIN"-NEXT:    [[_MSPROP_ICMP:%.*]] = and i1 false, [[TMP58]]
; CHECK-ORIGIN"-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC]], [[N]]
; CHECK-ORIGIN"-NEXT:    br i1 [[EXITCOND]], label %[[FOR_END]], label %[[FOR_BODY]]
; CHECK-ORIGIN":       [[FOR_END]]:
; CHECK-ORIGIN"-NEXT:    [[SUM_0_LCSSA:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[ADD]], %[[VAARG_END]] ]
; CHECK-ORIGIN"-NEXT:    call void @llvm.va_end.p0(ptr nonnull [[ARGS]])
; CHECK-ORIGIN"-NEXT:    call void @llvm.lifetime.end.p0(i64 24, ptr nonnull [[ARGS]])
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr @__msan_retval_origin_tls, align 4
; CHECK-ORIGIN"-NEXT:    ret i32 [[SUM_0_LCSSA]]
entry:
  %args = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %args) #2
  call void @llvm.va_start(ptr nonnull %args)
  %cmp9 = icmp sgt i32 %n, 0
  br i1 %cmp9, label %for.body.lr.ph, label %for.end




for.body.lr.ph:                                   ; preds = %entry
  %0 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0, i32 3
  %overflow_arg_area_p = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %args, i64 0, i64 0, i32 2
  %gp_offset.pre = load i32, ptr %args, align 16
  br label %for.body

for.body:                                         ; preds = %vaarg.end, %for.body.lr.ph
  %gp_offset = phi i32 [ %gp_offset.pre, %for.body.lr.ph ], [ %gp_offset12, %vaarg.end ]
  %sum.011 = phi i32 [ 0, %for.body.lr.ph ], [ %add, %vaarg.end ]
  %i.010 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %vaarg.end ]
  %fits_in_gp = icmp ult i32 %gp_offset, 41
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %for.body
  %reg_save_area = load ptr, ptr %0, align 16
  %1 = sext i32 %gp_offset to i64
  %2 = getelementptr i8, ptr %reg_save_area, i64 %1
  %3 = add i32 %gp_offset, 8
  store i32 %3, ptr %args, align 16
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %for.body
  %overflow_arg_area = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8, ptr %overflow_arg_area, i64 8
  store ptr %overflow_arg_area.next, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %gp_offset12 = phi i32 [ %3, %vaarg.in_reg ], [ %gp_offset, %vaarg.in_mem ]
  %vaarg.addr.in = phi ptr [ %2, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %4 = load i32, ptr %vaarg.addr.in, align 4
  %add = add nsw i32 %4, %sum.011
  %inc = add nuw nsw i32 %i.010, 1
  %exitcond = icmp eq i32 %inc, %n
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %vaarg.end, %entry
  %sum.0.lcssa = phi i32 [ 0, %entry ], [ %add, %vaarg.end ]
  call void @llvm.va_end(ptr nonnull %args)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %args) #2
  ret i32 %sum.0.lcssa
}


; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0(i64, ptr nocapture) #1

; Function Attrs: nounwind
declare void @llvm.va_start(ptr) #2

; Function Attrs: nounwind
declare void @llvm.va_end(ptr) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0(i64, ptr nocapture) #1

declare dso_local i80 @sum_i80(i32, ...) local_unnamed_addr

; Unaligned types like i80 should also work.
define dso_local i80 @test_i80(i80 %a, i80 %b, i80 %c) local_unnamed_addr {
; CHECK-ORIGIN-LABEL: define dso_local i80 @test_i80(
; CHECK-ORIGIN-SAME: i80 [[A:%.*]], i80 [[B:%.*]], i80 [[C:%.*]]) local_unnamed_addr {
; CHECK-ORIGIN-NEXT:  [[ENTRY:.*:]]
; CHECK-ORIGIN-NEXT:    call void @llvm.donothing()
; CHECK-ORIGIN-NEXT:    store i32 0, ptr @__msan_param_tls, align 8
; CHECK-ORIGIN-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 8) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 24) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 40) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 176) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i64 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 176) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr getelementptr (i32, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 176) to ptr), i32 2), align 8
; CHECK-ORIGIN-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 192) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i64 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 192) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr getelementptr (i32, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 192) to ptr), i32 2), align 8
; CHECK-ORIGIN-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 208) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i64 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 208) to ptr), align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr getelementptr (i32, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 208) to ptr), i32 2), align 8
; CHECK-ORIGIN-NEXT:    store i64 48, ptr @__msan_va_arg_overflow_size_tls, align 8
; CHECK-ORIGIN-NEXT:    store i80 0, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN-NEXT:    [[CALL:%.*]] = tail call i80 (i32, ...) @sum_i80(i32 3, i80 [[A]], i80 [[B]], i80 [[C]])
; CHECK-ORIGIN-NEXT:    [[_MSRET:%.*]] = load i80, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN-NEXT:    [[TMP0:%.*]] = load i32, ptr @__msan_retval_origin_tls, align 4
; CHECK-ORIGIN-NEXT:    store i80 0, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN-NEXT:    store i32 0, ptr @__msan_retval_origin_tls, align 4
; CHECK-ORIGIN-NEXT:    ret i80 [[CALL]]
;
; CHECK-ORIGIN"-LABEL: define dso_local i80 @test_i80(
; CHECK-ORIGIN"-SAME: i80 [[A:%.*]], i80 [[B:%.*]], i80 [[C:%.*]]) local_unnamed_addr {
; CHECK-ORIGIN"-NEXT:  [[ENTRY:.*:]]
; CHECK-ORIGIN"-NEXT:    call void @llvm.donothing()
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr @__msan_param_tls, align 8
; CHECK-ORIGIN"-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 8) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 24) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_param_tls to i64), i64 40) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 176) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i64 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 176) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr getelementptr (i32, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 176) to ptr), i32 2), align 8
; CHECK-ORIGIN"-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 192) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i64 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 192) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr getelementptr (i32, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 192) to ptr), i32 2), align 8
; CHECK-ORIGIN"-NEXT:    store i80 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_tls to i64), i64 208) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i64 0, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 208) to ptr), align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr getelementptr (i32, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__msan_va_arg_origin_tls to i64), i64 208) to ptr), i32 2), align 8
; CHECK-ORIGIN"-NEXT:    store i64 48, ptr @__msan_va_arg_overflow_size_tls, align 8
; CHECK-ORIGIN"-NEXT:    store i80 0, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN"-NEXT:    [[CALL:%.*]] = tail call i80 (i32, ...) @sum_i80(i32 3, i80 [[A]], i80 [[B]], i80 [[C]])
; CHECK-ORIGIN"-NEXT:    [[_MSRET:%.*]] = load i80, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN"-NEXT:    [[TMP0:%.*]] = load i32, ptr @__msan_retval_origin_tls, align 4
; CHECK-ORIGIN"-NEXT:    store i80 0, ptr @__msan_retval_tls, align 8
; CHECK-ORIGIN"-NEXT:    store i32 0, ptr @__msan_retval_origin_tls, align 4
; CHECK-ORIGIN"-NEXT:    ret i80 [[CALL]]
entry:
  %call = tail call i80 (i32, ...) @sum_i80(i32 3, i80 %a, i80 %b, i80 %c)
  ret i80 %call
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
