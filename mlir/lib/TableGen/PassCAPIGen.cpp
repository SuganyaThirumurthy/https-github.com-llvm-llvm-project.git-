//===- Pass.cpp - MLIR pass registration generator ------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// PassCAPIGen uses the description of passes to generate C API for the passes.
//
//===----------------------------------------------------------------------===//

#include "mlir/TableGen/CAPIGen.h"
#include "mlir/TableGen/Pass.h"

#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/TableGen/Record.h"

using namespace mlir;
using namespace mlir::tblgen;

const char *const passDecl = R"(
/* Create {0} Pass. */
MLIR_CAPI_EXPORTED MlirPass mlirCreate{0}{1}(void);
MLIR_CAPI_EXPORTED void mlirRegister{0}{1}(void);

)";

const char *const fileHeader = R"(
/* Autogenerated by mlir-tblgen; don't manually edit. */

#include "mlir-c/Pass.h"

#ifdef __cplusplus
extern "C" {
#endif

)";

const char *const fileFooter = R"(

#ifdef __cplusplus
}
#endif
)";

/// Emit TODO
bool mlir::tblgen::emitCAPIHeader(const llvm::RecordKeeper &records,
                                  raw_ostream &os, std::string groupPrefix) {
  os << fileHeader;
  os << "// Registration for the entire group\n";
  os << "MLIR_CAPI_EXPORTED void mlirRegister" << groupPrefix
     << "Passes(void);\n\n";
  for (const auto *def : records.getAllDerivedDefinitions("PassBase")) {
    Pass pass(def);
    StringRef defName = pass.getDef()->getName();
    os << llvm::formatv(passDecl, groupPrefix, defName);
  }
  os << fileFooter;
  return false;
}

const char *const passCreateDef = R"(
MlirPass mlirCreate{0}{1}(void) {
  return wrap({2}.release());
}
void mlirRegister{0}{1}(void) {
  register{1}();
}

)";

/// {0}: The name of the pass group.
const char *const passGroupRegistrationCode = R"(
//===----------------------------------------------------------------------===//
// {0} Group Registration
//===----------------------------------------------------------------------===//

void mlirRegister{0}Passes(void) {{
  register{0}Passes();
}
)";

bool mlir::tblgen::emitCAPIImpl(const llvm::RecordKeeper &records,
                                raw_ostream &os, std::string groupPrefix) {
  os << "/* Autogenerated by mlir-tblgen; don't manually edit. */";
  os << llvm::formatv(passGroupRegistrationCode, groupPrefix);

  for (const auto *def : records.getAllDerivedDefinitions("PassBase")) {
    Pass pass(def);
    StringRef defName = pass.getDef()->getName();

    std::string constructorCall;
    if (StringRef constructor = pass.getConstructor(); !constructor.empty())
      constructorCall = constructor.str();
    else
      constructorCall =
          llvm::formatv("create{0}()", pass.getDef()->getName()).str();

    os << llvm::formatv(passCreateDef, groupPrefix, defName, constructorCall);
  }
  return false;
}
